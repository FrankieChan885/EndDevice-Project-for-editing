###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.10194/W32 for 8051         21/Apr/2015  16:52:41 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Components\hal\target\CC2530EB\h #
#                          al_key.c                                           #
#    Command line       =  -f C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice #
#                          -Project-for-editing\Projects\zstack\MyEnddevice\E #
#                          ndDevice\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev #
#                          .cfg (-DCPU32MHZ -DROOT=__near_func                #
#                          -DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6         #
#                          -DMAC_CFG_RX_MAX=3) -f C:\Users\William\Desktop\±œ #
#                          “µ…Ëº∆\SRC\EndDevice-Project-for-editing\Projects\ #
#                          zstack\MyEnddevice\EndDevice\CC2530DB\..\..\..\Too #
#                          ls\CC2530DB\f8wConfig.cfg (-DZIGBEEPRO -DSECURE=0  #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x02000000                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 C:\Users\William\Desktop\±œ #
#                          “µ…Ëº∆\SRC\EndDevice-Project-for-editing\Component #
#                          s\hal\target\CC2530EB\hal_key.c -D NWK_AUTO_POLL   #
#                          -D NV_RESTORE=1 -D xZTOOL_P1 -D xMT_TASK -D        #
#                          xMT_SYS_FUNC -D xMT_ZDO_FUNC -D                    #
#                          xLCD_SUPPORTED=DEBUG -lC                           #
#                          C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\EndDeviceEB\List\ -lA               #
#                          C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\EndDeviceEB\List\ --diag_suppress   #
#                          Pe001,Pa010 -o C:\Users\William\Desktop\±œ“µ…Ëº∆\S #
#                          RC\EndDevice-Project-for-editing\Projects\zstack\M #
#                          yEnddevice\EndDevice\CC2530DB\EndDeviceEB\Obj\ -e  #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice #
#                          -Project-for-editing\Projects\zstack\MyEnddevice\E #
#                          ndDevice\CC2530DB\ -I C:\Users\William\Desktop\±œ“ #
#                          µ…Ëº∆\SRC\EndDevice-Project-for-editing\Projects\z #
#                          stack\MyEnddevice\EndDevice\CC2530DB\..\Source\    #
#                          -I C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice #
#                          -Project-for-editing\Projects\zstack\MyEnddevice\E #
#                          ndDevice\CC2530DB\..\..\..\ZMain\TI2530DB\ -I      #
#                          C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\..\..\..\..\..\Components\hal\inclu #
#                          de\ -I C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDe #
#                          vice-Project-for-editing\Projects\zstack\MyEnddevi #
#                          ce\EndDevice\CC2530DB\..\..\..\..\..\Components\ha #
#                          l\target\CC2530EB\ -I C:\Users\William\Desktop\±œ“ #
#                          µ…Ëº∆\SRC\EndDevice-Project-for-editing\Projects\z #
#                          stack\MyEnddevice\EndDevice\CC2530DB\..\..\..\..\. #
#                          .\Components\mac\include\ -I                       #
#                          C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\..\..\..\..\..\Components\mac\high_ #
#                          level\ -I C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\En #
#                          dDevice-Project-for-editing\Projects\zstack\MyEndd #
#                          evice\EndDevice\CC2530DB\..\..\..\..\..\Components #
#                          \mac\low_level\srf04\ -I                           #
#                          C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\..\..\..\..\..\Components\mac\low_l #
#                          evel\srf04\single_chip\ -I                         #
#                          C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\..\..\..\..\..\Components\mt\ -I    #
#                          C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\..\..\..\..\..\Components\osal\incl #
#                          ude\ -I C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndD #
#                          evice-Project-for-editing\Projects\zstack\MyEnddev #
#                          ice\EndDevice\CC2530DB\..\..\..\..\..\Components\s #
#                          ervices\saddr\ -I C:\Users\William\Desktop\±œ“µ…Ëº #
#                          ∆\SRC\EndDevice-Project-for-editing\Projects\zstac #
#                          k\MyEnddevice\EndDevice\CC2530DB\..\..\..\..\..\Co #
#                          mponents\services\sdata\ -I                        #
#                          C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\..\..\..\..\..\Components\stack\af\ #
#                           -I C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevic #
#                          e-Project-for-editing\Projects\zstack\MyEnddevice\ #
#                          EndDevice\CC2530DB\..\..\..\..\..\Components\stack #
#                          \nwk\ -I C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\End #
#                          Device-Project-for-editing\Projects\zstack\MyEndde #
#                          vice\EndDevice\CC2530DB\..\..\..\..\..\Components\ #
#                          stack\sapi\ -I C:\Users\William\Desktop\±œ“µ…Ëº∆\S #
#                          RC\EndDevice-Project-for-editing\Projects\zstack\M #
#                          yEnddevice\EndDevice\CC2530DB\..\..\..\..\..\Compo #
#                          nents\stack\sec\ -I C:\Users\William\Desktop\±œ“µ… #
#                          Ëº∆\SRC\EndDevice-Project-for-editing\Projects\zst #
#                          ack\MyEnddevice\EndDevice\CC2530DB\..\..\..\..\..\ #
#                          Components\stack\sys\ -I                           #
#                          C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\..\..\..\..\..\Components\stack\zdo #
#                          \ -I C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevi #
#                          ce-Project-for-editing\Projects\zstack\MyEnddevice #
#                          \EndDevice\CC2530DB\..\..\..\..\..\Components\zmac #
#                          \ -I C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevi #
#                          ce-Project-for-editing\Projects\zstack\MyEnddevice #
#                          \EndDevice\CC2530DB\..\..\..\..\..\Components\zmac #
#                          \f8w\ -Ohz                                         #
#    List file          =  C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\EndDeviceEB\List\hal_key.lst        #
#    Object file        =  C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\EndDeviceEB\Obj\hal_key.r51         #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Project-for-editing\Components\hal\target\CC2530EB\hal_key.c
      1          /**************************************************************************************************
      2            Filename:       hal_key.c
      3            Revised:        $Date: 2010-09-15 19:02:45 -0700 (Wed, 15 Sep 2010) $
      4            Revision:       $Revision: 23815 $
      5          
      6            Description:    This file contains the interface to the HAL KEY Service.
      7          
      8          
      9            Copyright 2006-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED ìAS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          /*********************************************************************
     40           NOTE: If polling is used, the hal_driver task schedules the KeyRead()
     41                 to occur every 100ms.  This should be long enough to naturally
     42                 debounce the keys.  The KeyRead() function remembers the key
     43                 hal_key_mode of the previous poll and will only return a non-zero
     44                 value if the key hal_key_mode changes.
     45          
     46           NOTE: If interrupts are used, the KeyRead() function is scheduled
     47                 25ms after the interrupt occurs by the ISR.  This delay is used
     48                 for key debouncing.  The ISR disables any further Key interrupt
     49                 until KeyRead() is executed.  KeyRead() will re-enable Key
     50                 interrupts after executing.  Unlike polling, when interrupts
     51                 are enabled, the previous key hal_key_mode is not remembered.  This
     52                 means that KeyRead() will return the current hal_key_mode of the keys
     53                 (not a change in hal_key_mode of the keys).
     54          
     55           NOTE: If interrupts are used, the KeyRead() fucntion is scheduled by
     56                 the ISR.  Therefore, the joystick movements will only be detected
     57                 during a pushbutton interrupt caused by S1 or the center joystick
     58                 pushbutton.
     59          
     60           NOTE: When a switch like S1 is pushed, the S1 signal goes from a normally
     61                 high hal_key_mode to a low hal_key_mode.  This transition is typically clean.  The
     62                 duration of the low hal_key_mode is around 200ms.  When the signal returns
     63                 to the high hal_key_mode, there is a high likelihood of signal bounce, which
     64                 causes a unwanted interrupts.  Normally, we would set the interrupt
     65                 edge to falling edge to generate an interrupt when S1 is pushed, but
     66                 because of the signal bounce, it is better to set the edge to rising
     67                 edge to generate an interrupt when S1 is released.  The debounce logic
     68                 can then filter out the signal bounce.  The result is that we typically
     69                 get only 1 interrupt per button push.  This mechanism is not totally
     70                 foolproof because occasionally, signal bound occurs during the falling
     71                 edge as well.  A similar mechanism is used to handle the joystick
     72                 pushbutton on the DB.  For the EB, we do not have independent control
     73                 of the interrupt edge for the S1 and center joystick pushbutton.  As
     74                 a result, only one or the other pushbuttons work reasonably well with
     75                 interrupts.  The default is the make the S1 switch on the EB work more
     76                 reliably.
     77          
     78          *********************************************************************/
     79          
     80          /**************************************************************************************************
     81           *                                            INCLUDES
     82           **************************************************************************************************/
     83          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xab
   \   unsigned char volatile __sfr P0IEN
   \                     P0IEN:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf7
   \   unsigned char volatile __sfr P2INP
   \                     P2INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1
     84          #include "hal_defs.h"
     85          #include "hal_types.h"
     86          #include "hal_board.h"
     87          #include "hal_drivers.h"
     88          #include "hal_adc.h"
     89          #include "hal_key.h"
     90          #include "osal.h"
     91          
     92          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
     93          
     94          /**************************************************************************************************
     95           *                                              MACROS
     96           **************************************************************************************************/
     97          
     98          /**************************************************************************************************
     99           *                                            CONSTANTS
    100           **************************************************************************************************/
    101          #define HAL_KEY_RISING_EDGE   0
    102          #define HAL_KEY_FALLING_EDGE  1
    103          #define HAL_KEY_DEBOUNCE_VALUE  25
    104          
    105          
    106          /* CPU port interrupt flats*/ 
    107          #define HAL_KEY_CPU_PORT_0_IF P0IF
    108          #define HAL_KEY_CPU_PORT_2_IF P2IF
    109          
    110          /* SW is at P0*///By Peng Tao
    111          #define HAL_KEY_PORT     P0
    112          #define HAL_KEY_1_BIT    BV(3)//KEY1 is at P0.3
    113          #define HAL_KEY_2_BIT    BV(2)//KEY2 is at P0.2
    114          #define HAL_KEY_3_BIT    BV(4)//KEY3 is at P0.4
    115          #define HAL_KEY_4_BIT    BV(1)//KEY4 is at P0.1
    116          #define HAL_KEY_5_BIT    BV(0)//KEY5 is at P0.0
    117          #define HAL_KEY_SEL      P0SEL// register  of selecting the function of  P0  
    118          #define HAL_KEY_DIR      P0DIR// register  of selecting the direction of  P0 
    119          
    120          
    121          /* Switch interrupts *///By Peng Tao
    122          #define CPU_ICTL             IEN1  /* CPU interrupt mask register 1 */
    123          #define HAL_KEY_CPU_ICTLBIT  BV(5)
    124          #define HAL_KEY_ICTL         P0IEN /* P0 Interrupt Control register */
    125          #define HAL_KEY_1_ICTLBIT    BV(3)//KEY1 interrupt control bit is at P0IEN.3
    126          #define HAL_KEY_2_ICTLBIT    BV(2)//KEY2 interrupt control bit is at P0IEN.2
    127          #define HAL_KEY_3_ICTLBIT    BV(4)//KEY3 interrupt control bit is at P0IEN.4
    128          #define HAL_KEY_4_ICTLBIT    BV(1)//KEY4 interrupt control bit is at P0IEN.1
    129          #define HAL_KEY_5_ICTLBIT    BV(0)//KEY5 interrupt control bit is at P0IEN.0
    130          
    131          
    132          
    133          /*Switch Port input hal_key_mode(pulldown/pullup or 3-State)*/ //By Peng Tao
    134          #define HAL_KEY_INPUTMODE        P0INP // P0 INPUT MODE SET
    135          #define HAL_KEY_1_INPMODEBIT     BV(3)//KEY1 INPUT MODE SELECTION BIT IS AT P0INP.3 
    136          #define HAL_KEY_2_INPMODEBIT     BV(2)//KEY2 INPUT MODE SELECTION BIT IS AT P0INP.2 
    137          #define HAL_KEY_3_INPMODEBIT     BV(4)//KEY3 INPUT MODE SELECTION BIT IS AT P0INP.4 
    138          #define HAL_KEY_4_INPMODEBIT     BV(1)//KEY4 INPUT MODE SELECTION BIT IS AT P0INP.1 
    139          #define HAL_KEY_5_INPMODEBIT     BV(0)//KEY5 INPUT MODE SELECTION BIT IS AT P0INP.0 
    140          
    141          /*selecting the port for pulldown or pullup,when Switch port is select for pulldown/pullup hal_key_mode */ //By Peng Tao
    142          #define HAL_KEY_PULL_DUP    P2INP  // the register for selecting the pulldown or pullup hal_key_mode for  P0,P1,P2
    143          #define HAL_KEY_PULL_DUPBIT BV(5)  // PDUP0 is the P2INP.5
    144          
    145          
    146          #define MAX_DOUBLE_HIT_GAP   8// the maxium gap of double hit
    147          
    148          
    149          
    150          
    151          /**************************************************************************************************
    152           *                                            TYPEDEFS
    153          
    154           **************************************************************************************************/
    155          
    156          
    157          
    158          /**************************************************************************************************
    159           *                                        GLOBAL VARIABLES
    160           **************************************************************************************************/
    161          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    162          static halKeyCBack_t pHalKeyProcessFunction;
   \                     pHalKeyProcessFunction:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    163          static uint8 HalKeyConfigured;
   \                     HalKeyConfigured:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    164          bool  Hal_KeyIntEnable;            /* interrupt enable/disable flag */
   \                     Hal_KeyIntEnable:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    165          //uint8 POWER_KEY_COUNT = 0;   
    166          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    167          uint8 double_hit_count = 0;// the key was pressing ,ant the hit_count recorde the count 
   \                     double_hit_count:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    168          bool  double_hit = FALSE;  // the key double hit or not;
   \                     double_hit:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    169          uint8 key_depressed_gap = 0; // the gap betweet the double hit
   \                     key_depressed_gap:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    170          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    171          static uint8 halKeySavedKeystate;     /* used to store previous key hal_key_mode in polling hal_key_mode */
   \                     halKeySavedKeystate:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    172          static uint8 halKeySavedKeybounce = 0; // the keybouced  hal_key_mode last
   \                     halKeySavedKeybounce:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    173          static uint8 keystate  = 0; // if the key is pressed , the corresponding bit is set to be high
   \                     keystate:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    174          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    175          uint8 hal_key_mode = 0x00; // hal_key_mode = 0x00 the normal hal_key_mode;hal_key_mode = 0x01 the shift pressed;
   \                     hal_key_mode:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    176          // hal_key_mode = 0x02 the shift depressed,hal_key_mode = 0x03 exit the double_hit hal_key_mode; 
    177          /**************************************************************************************************
    178           *                                        FUNCTIONS - Local
    179           **************************************************************************************************/
    180          void halProcessKeyInterrupt(void);
    181          
    182          
    183          
    184          /**************************************************************************************************
    185           *                                        FUNCTIONS - API
    186           **************************************************************************************************/
    187          
    188          
    189          /**************************************************************************************************
    190           * @fn      HalKeyInit
    191           *
    192           * @brief   Initilize Key Service
    193           *
    194           * @param   none
    195           *
    196           * @return  None
    197           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    198          void HalKeyInit( void )
   \                     HalKeyInit:
    199          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    200            /* Initialize previous key to 0 */
    201            halKeySavedKeystate = 0;
   \   000004   90....       MOV     DPTR,#halKeySavedKeystate
   \   000007   E4           CLR     A
   \   000008   F0           MOVX    @DPTR,A
    202            HAL_KEY_SEL &= ~(HAL_KEY_1_BIT + HAL_KEY_2_BIT + HAL_KEY_3_BIT + HAL_KEY_4_BIT + HAL_KEY_5_BIT);    /* Set key1,2,3,4,5 pin 3,2,4,1,0 function to GPIO */
   \   000009   53F3E0       ANL     0xf3,#0xe0
    203            HAL_KEY_DIR &= ~(HAL_KEY_1_BIT + HAL_KEY_2_BIT + HAL_KEY_3_BIT + HAL_KEY_4_BIT + HAL_KEY_5_BIT);    /* Set pin direction to Input */
   \   00000C   53FDE0       ANL     0xfd,#0xe0
    204            CPU_ICTL &= ~(HAL_KEY_CPU_ICTLBIT);  // disable the P0 interrupt 
   \   00000F   C2BD         CLR     0xb8.5
    205            HAL_KEY_ICTL &=  ~(HAL_KEY_1_ICTLBIT + HAL_KEY_2_ICTLBIT + HAL_KEY_3_ICTLBIT + 
    206                               HAL_KEY_4_ICTLBIT + HAL_KEY_5_ICTLBIT); // disable the key's interrupts
   \   000011   53ABE0       ANL     0xab,#0xe0
    207            HAL_KEY_INPUTMODE &= ~(HAL_KEY_1_INPMODEBIT + HAL_KEY_2_INPMODEBIT + HAL_KEY_3_INPMODEBIT +
    208                                  HAL_KEY_4_INPMODEBIT + HAL_KEY_5_INPMODEBIT);// SET THE KEY INPUT PIN TO BE PULLDOWN OR PULLUP MODE;
   \   000014   538FE0       ANL     0x8f,#0xe0
    209            HAL_KEY_PULL_DUP &=  ~HAL_KEY_PULL_DUPBIT; // SET TEH KEY INPUT PINS TO BE PULLUP MODE;
   \   000017   53F7DF       ANL     0xf7,#0xdf
    210          
    211            
    212            /* Initialize callback function */
    213            pHalKeyProcessFunction  = NULL;
   \   00001A   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   A3           INC     DPTR
   \   00001F   F0           MOVX    @DPTR,A
    214            /* Start with key is not configured */
    215            HalKeyConfigured = FALSE;
   \   000020   90....       MOV     DPTR,#HalKeyConfigured
   \   000023   F0           MOVX    @DPTR,A
    216          }
   \   000024                REQUIRE ?Subroutine0
   \   000024                REQUIRE P0SEL
   \   000024                REQUIRE P0DIR
   \   000024                REQUIRE _A_IEN1
   \   000024                REQUIRE P0IEN
   \   000024                REQUIRE P0INP
   \   000024                REQUIRE P2INP
   \   000024                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    217          
    218          
    219          /**************************************************************************************************
    220           * @fn      HalKeyConfig
    221           *
    222           * @brief   Configure the Key serivce
    223           *
    224           * @param   interruptEnable - TRUE/FALSE, enable/disable interrupt
    225           *          cback - pointer to the CallBack function
    226           *
    227           * @return  None
    228           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    229          void HalKeyConfig (bool interruptEnable, halKeyCBack_t cback)
   \                     HalKeyConfig:
    230          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
    231            /* Enable/Disable Interrupt or */
    232            Hal_KeyIntEnable = interruptEnable;
   \   000006   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000009   F0           MOVX    @DPTR,A
    233          
    234            /* Register the callback fucntion */
    235            pHalKeyProcessFunction = cback;
   \   00000A   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00000D   EA           MOV     A,R2
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   EB           MOV     A,R3
   \   000011   F0           MOVX    @DPTR,A
    236          
    237            /* Determine if interrupt is enable or not */
    238            if (Hal_KeyIntEnable)
   \   000012   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000015   E0           MOVX    A,@DPTR
   \   000016   6016         JZ      ??HalKeyConfig_0
    239            {
    240              /* Do this only after the hal_key is configured - to work with sleep stuff */
    241              if (HalKeyConfigured == TRUE)
   \   000018   90....       MOV     DPTR,#HalKeyConfigured
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   6401         XRL     A,#0x1
   \   00001E   701A         JNZ     ??HalKeyConfig_1
    242              {
    243                osal_stop_timerEx(Hal_TaskID, HAL_KEY_EVENT);  /* Cancel polling if active */
   \   000020                ; Setup parameters for call to function osal_stop_timerEx
   \   000020   7A01         MOV     R2,#0x1
   \   000022   7B00         MOV     R3,#0x0
   \   000024   90....       MOV     DPTR,#Hal_TaskID
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F9           MOV     R1,A
   \   000029   12....       LCALL   ??osal_stop_timerEx?relay
   \   00002C   800C         SJMP    ??HalKeyConfig_1
    244              }
    245            }
    246            else    /* Interrupts NOT enabled */
    247            {
    248              osal_set_event(Hal_TaskID, HAL_KEY_EVENT);
   \                     ??HalKeyConfig_0:
   \   00002E                ; Setup parameters for call to function osal_set_event
   \   00002E   7A01         MOV     R2,#0x1
   \   000030   7B00         MOV     R3,#0x0
   \   000032   90....       MOV     DPTR,#Hal_TaskID
   \   000035   E0           MOVX    A,@DPTR
   \   000036   F9           MOV     R1,A
   \   000037   12....       LCALL   ??osal_set_event?relay
    249            }
    250          
    251            /* Key now is configured */
    252            HalKeyConfigured = TRUE;
   \                     ??HalKeyConfig_1:
   \   00003A   90....       MOV     DPTR,#HalKeyConfigured
   \   00003D   7401         MOV     A,#0x1
   \   00003F   F0           MOVX    @DPTR,A
    253          }
   \   000040   FF           MOV     R7,A
   \   000041   02....       LJMP    ?BANKED_LEAVE_XDATA
    254          
    255          
    256          /**************************************************************************************************
    257           * @fn      HalKeyRead
    258           *
    259           * @brief   Read the current hal_key_mode of a key
    260           *
    261           * @param   None
    262           *
    263           * @return  keys - current keys status
    264           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    265          uint8 HalKeyRead ( void )
   \                     HalKeyRead:
    266          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    267            uint8 keys = 0;
   \   000000   7900         MOV     R1,#0x0
    268            if(!(HAL_KEY_PORT & HAL_KEY_1_BIT)) // KEY 1 Pressed
   \   000002   A283         MOV     C,0x80.3
   \   000004   4001         JC      ??HalKeyRead_0
    269            {
    270               keys |= HAL_KEY_DEC;
   \   000006   09           INC     R1
    271            }
    272            
    273            if(!(HAL_KEY_PORT & HAL_KEY_2_BIT)) // KEY 2 Pressed
   \                     ??HalKeyRead_0:
   \   000007   A282         MOV     C,0x80.2
   \   000009   4004         JC      ??HalKeyRead_1
    274            {
    275               keys |= HAL_KEY_INC;
   \   00000B   E9           MOV     A,R1
   \   00000C   D2E1         SETB    0xE0 /* A   */.1
   \   00000E   F9           MOV     R1,A
    276            }
    277            
    278            if(!(HAL_KEY_PORT & HAL_KEY_3_BIT)) // KEY 3 Pressed
   \                     ??HalKeyRead_1:
   \   00000F   A284         MOV     C,0x80.4
   \   000011   4004         JC      ??HalKeyRead_2
    279            {
    280               keys |= HAL_KEY_PWR;
   \   000013   E9           MOV     A,R1
   \   000014   D2E2         SETB    0xE0 /* A   */.2
   \   000016   F9           MOV     R1,A
    281            }
    282            
    283            if(!(HAL_KEY_PORT & HAL_KEY_4_BIT)) // KEY 4 Pressed
   \                     ??HalKeyRead_2:
   \   000017   A281         MOV     C,0x80.1
   \   000019   4004         JC      ??HalKeyRead_3
    284            {
    285               keys |= HAL_KEY_FLR;
   \   00001B   E9           MOV     A,R1
   \   00001C   D2E3         SETB    0xE0 /* A   */.3
   \   00001E   F9           MOV     R1,A
    286            }
    287            
    288            
    289            if(!(HAL_KEY_PORT & HAL_KEY_5_BIT)) // KEY 5 Pressed
   \                     ??HalKeyRead_3:
   \   00001F   A280         MOV     C,0x80.0
   \   000021   4004         JC      ??HalKeyRead_4
    290            {
    291               keys |= HAL_KEY_AIR;
   \   000023   E9           MOV     A,R1
   \   000024   D2E4         SETB    0xE0 /* A   */.4
   \   000026   F9           MOV     R1,A
    292            }
    293            
    294            return keys;
   \                     ??HalKeyRead_4:
   \   000027   02....       LJMP    ?BRET
   \   00002A                REQUIRE _A_P0
    295          }
    296          
    297          /**************************************************************************************************
    298           * @fn      HalKeyBounce
    299           *
    300           * @brief   judge wether the keys  bounce or not
    301           *
    302           * @param   None
    303           *
    304           * @return  the keys bounce
    305           **************************************************************************************************/
    306          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    307          uint8 HalKeyBounce( void )
   \                     HalKeyBounce:
    308          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    309            uint8 keys = 0;
   \   000004   7900         MOV     R1,#0x0
    310            if(halKeySavedKeystate & HAL_KEY_DEC) // KEY 1 was Pressed
    311            {
    312               if(!(keystate & HAL_KEY_DEC))// KEY 1 Bounce now/depressd
   \   000006   90....       MOV     DPTR,#keystate
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000C   B3           CPL     C
   \   00000D   C0D0         PUSH    PSW
   \   00000F   90....       MOV     DPTR,#halKeySavedKeystate
   \   000012   E0           MOVX    A,@DPTR
   \   000013   A2E0         MOV     C,0xE0 /* A   */.0
   \   000015   92F0         MOV     B.0,C
   \   000017   12....       LCALL   ?POP_BIT_ISP
   \   00001A   1581         DEC     SP
   \   00001C   82F0         ANL     C,B.0
   \   00001E   5001         JNC     ??HalKeyBounce_0
    313               keys |= HAL_KEY_DEC;
   \   000020   09           INC     R1
    314            }
    315            
    316            if(halKeySavedKeystate & HAL_KEY_INC) // KEY 2  was Pressed 
    317            {
    318               if(!(keystate & HAL_KEY_INC))// KEY 2 Bounc now/depressd
   \                     ??HalKeyBounce_0:
   \   000021   A2E1         MOV     C,0xE0 /* A   */.1
   \   000023   500C         JNC     ??HalKeyBounce_1
   \   000025   90....       MOV     DPTR,#keystate
   \   000028   E0           MOVX    A,@DPTR
   \   000029   A2E1         MOV     C,0xE0 /* A   */.1
   \   00002B   4004         JC      ??HalKeyBounce_1
    319               keys |= HAL_KEY_INC;
   \   00002D   E9           MOV     A,R1
   \   00002E   D2E1         SETB    0xE0 /* A   */.1
   \   000030   F9           MOV     R1,A
    320            }
    321            
    322            if(halKeySavedKeystate & HAL_KEY_PWR) // KEY 3  was Pressed
    323            {
    324               if(!(keystate & HAL_KEY_PWR))// KEY 3 Bounce now/depressd
   \                     ??HalKeyBounce_1:
   \   000031   90....       MOV     DPTR,#halKeySavedKeystate
   \   000034   E0           MOVX    A,@DPTR
   \   000035   A2E2         MOV     C,0xE0 /* A   */.2
   \   000037   500C         JNC     ??HalKeyBounce_2
   \   000039   90....       MOV     DPTR,#keystate
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   A2E2         MOV     C,0xE0 /* A   */.2
   \   00003F   4004         JC      ??HalKeyBounce_2
    325               keys |= HAL_KEY_PWR;
   \   000041   E9           MOV     A,R1
   \   000042   D2E2         SETB    0xE0 /* A   */.2
   \   000044   F9           MOV     R1,A
    326            }
    327            
    328           if(halKeySavedKeystate & HAL_KEY_FLR) // KEY 4 was Pressed
    329            {
    330               if(!(keystate & HAL_KEY_FLR))// KEY 4 Bounce now/depressd
   \                     ??HalKeyBounce_2:
   \   000045   90....       MOV     DPTR,#halKeySavedKeystate
   \   000048   E0           MOVX    A,@DPTR
   \   000049   A2E3         MOV     C,0xE0 /* A   */.3
   \   00004B   500C         JNC     ??HalKeyBounce_3
   \   00004D   90....       MOV     DPTR,#keystate
   \   000050   E0           MOVX    A,@DPTR
   \   000051   A2E3         MOV     C,0xE0 /* A   */.3
   \   000053   4004         JC      ??HalKeyBounce_3
    331               keys |= HAL_KEY_FLR;
   \   000055   E9           MOV     A,R1
   \   000056   D2E3         SETB    0xE0 /* A   */.3
   \   000058   F9           MOV     R1,A
    332            }
    333            
    334            
    335           if(halKeySavedKeystate & HAL_KEY_AIR) // KEY 5 was Pressed
    336            {
    337               if(!(keystate & HAL_KEY_AIR))// KEY 5 Bounce now/depressd
   \                     ??HalKeyBounce_3:
   \   000059   90....       MOV     DPTR,#halKeySavedKeystate
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   A2E4         MOV     C,0xE0 /* A   */.4
   \   00005F   500C         JNC     ??HalKeyBounce_4
   \   000061   90....       MOV     DPTR,#keystate
   \   000064   E0           MOVX    A,@DPTR
   \   000065   A2E4         MOV     C,0xE0 /* A   */.4
   \   000067   4004         JC      ??HalKeyBounce_4
    338               keys |= HAL_KEY_AIR;
   \   000069   E9           MOV     A,R1
   \   00006A   D2E4         SETB    0xE0 /* A   */.4
   \   00006C   F9           MOV     R1,A
    339            }
    340            return keys;
   \                     ??HalKeyBounce_4:
   \   00006D   02....       LJMP    ?Subroutine0 & 0xFFFF
    341          }
    342          /**************************************************************************************************
    343           * @fn      HalKeyPoll
    344           *
    345           * @brief   Called by hal_driver to poll the keys
    346           *
    347           * @param   None
    348           *
    349           * @return  None
    350           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    351          void HalKeyPoll (void)
   \                     HalKeyPoll:
    352          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    353              
    354              uint8 keysbounce = 0;
    355              keystate = HalKeyRead();// read the key hal_key_mode now
   \   000005                ; Setup parameters for call to function HalKeyRead
   \   000005   12....       LCALL   ??HalKeyRead?relay
   \   000008   E9           MOV     A,R1
   \   000009   90....       MOV     DPTR,#keystate
   \   00000C   F0           MOVX    @DPTR,A
    356              keysbounce = HalKeyBounce();// read the key bounce now
   \   00000D                ; Setup parameters for call to function HalKeyBounce
   \   00000D   12....       LCALL   ??HalKeyBounce?relay
   \   000010   E9           MOV     A,R1
   \   000011   FE           MOV     R6,A
    357              
    358            /* If interrupts are not enabled, previous key status and current key status
    359             * are compared to find out if a key has changed status.
    360             */
    361            if (!Hal_KeyIntEnable)
   \   000012   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000015   E0           MOVX    A,@DPTR
   \   000016   6003         JZ      $+5
   \   000018   02....       LJMP    ??HalKeyPoll_0 & 0xFFFF
    362            {
    363              
    364              // exit the double_hit mode  
    365              if(hal_key_mode == 0x03)
   \   00001B   90....       MOV     DPTR,#hal_key_mode
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6403         XRL     A,#0x3
   \   000021   7015         JNZ     ??HalKeyPoll_1
    366              {
    367                (pHalKeyProcessFunction) (keysbounce, HAL_KEY_STATE_EIXT_DOUBLE_HIT);
   \   000023                ; Setup parameters for indirect call
   \   000023   7A03         MOV     R2,#0x3
   \   000025   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F8           MOV     R0,A
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F583         MOV     DPH,A
   \   00002E   8882         MOV     DPL,R0
   \   000030   12....       LCALL   ?CALL_IND
    368                hal_key_mode = 0x00;
   \   000033   90....       MOV     DPTR,#hal_key_mode
   \   000036   E4           CLR     A
   \   000037   F0           MOVX    @DPTR,A
    369              }
    370              
    371              /* Store the current keys for comparation next time */
    372              halKeySavedKeystate = keystate;
   \                     ??HalKeyPoll_1:
   \   000038   90....       MOV     DPTR,#keystate
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   90....       MOV     DPTR,#halKeySavedKeystate
   \   00003F   F0           MOVX    @DPTR,A
    373                
    374               /* Invoke Callback if new keys were depressed */
    375              if (keysbounce && (pHalKeyProcessFunction))
   \   000040   EE           MOV     A,R6
   \   000041   606E         JZ      ??HalKeyPoll_0
   \   000043   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F8           MOV     R0,A
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   F9           MOV     R1,A
   \   00004B   E8           MOV     A,R0
   \   00004C   49           ORL     A,R1
   \   00004D   6062         JZ      ??HalKeyPoll_0
    376              {
    377                  /***********************whether the double_hit mode************/
    378                  if( (keysbounce == halKeySavedKeybounce) &&
    379                      (
    380                          (keysbounce & HAL_KEY_DEC) || 
    381                          (keysbounce & HAL_KEY_INC)
    382                      ) && 
    383                      (hal_key_mode == 0x00) // only can double hit in the normal mode 
    384                     )// the same key depressed 
   \   00004F   90....       MOV     DPTR,#halKeySavedKeybounce
   \   000052   E0           MOVX    A,@DPTR
   \   000053   6E           XRL     A,R6
   \   000054   701A         JNZ     ??HalKeyPoll_2
   \   000056   7403         MOV     A,#0x3
   \   000058   5E           ANL     A,R6
   \   000059   6015         JZ      ??HalKeyPoll_2
   \   00005B   90....       MOV     DPTR,#hal_key_mode
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   700F         JNZ     ??HalKeyPoll_2
    385                  {
    386                    //if the gap is less than the MAX_DOUBLE_HIT_GAP, the key double hit
    387                    if(key_depressed_gap < MAX_DOUBLE_HIT_GAP)
   \   000061   90....       MOV     DPTR,#key_depressed_gap
   \   000064   E0           MOVX    A,@DPTR
   \   000065   C3           CLR     C
   \   000066   9408         SUBB    A,#0x8
   \   000068   5006         JNC     ??HalKeyPoll_2
    388                    {
    389                      double_hit = TRUE;
   \   00006A   90....       MOV     DPTR,#double_hit
   \   00006D   7401         MOV     A,#0x1
   \   00006F   F0           MOVX    @DPTR,A
    390                      //double_hit_count++; //and start the count for next double hit 
    391                    }
    392                  }
    393                  /***********************whether the double_hit mode************/
    394                  
    395                  
    396                // only save the kesbounce when the key depressed
    397                halKeySavedKeybounce = keysbounce;
   \                     ??HalKeyPoll_2:
   \   000070   EE           MOV     A,R6
   \   000071   90....       MOV     DPTR,#halKeySavedKeybounce
   \   000074   F0           MOVX    @DPTR,A
    398                if(keystate & HAL_KEY_PWR)  // the shift is pressed ,another key is depressed 
   \   000075   90....       MOV     DPTR,#keystate
   \   000078   E0           MOVX    A,@DPTR
   \   000079   A2E2         MOV     C,0xE0 /* A   */.2
   \   00007B   5017         JNC     ??HalKeyPoll_3
    399                {
    400                  (pHalKeyProcessFunction) (keysbounce, HAL_KEY_STATE_SHIFT);
   \   00007D                ; Setup parameters for indirect call
   \   00007D   7A01         MOV     R2,#0x1
   \   00007F   EE           MOV     A,R6
   \   000080   F9           MOV     R1,A
   \   000081   90....       MOV     DPTR,#pHalKeyProcessFunction + 1
   \   000084   E0           MOVX    A,@DPTR
   \   000085   F583         MOV     DPH,A
   \   000087   8882         MOV     DPL,R0
   \   000089   12....       LCALL   ?CALL_IND
    401                   hal_key_mode = 0x01; 
   \   00008C   90....       MOV     DPTR,#hal_key_mode
   \   00008F   7401         MOV     A,#0x1
   \   000091   F0           MOVX    @DPTR,A
   \   000092   801D         SJMP    ??HalKeyPoll_0
    402                }
    403                else // not the shift hal_key_mode or exit the shift hal_key_mode 
    404                {
    405                  if(hal_key_mode == 0x01)// in the shift hal_key_mode, the shift depressed 
   \                     ??HalKeyPoll_3:
   \   000094   90....       MOV     DPTR,#hal_key_mode
   \   000097   E0           MOVX    A,@DPTR
   \   000098   6401         XRL     A,#0x1
   \   00009A   7006         JNZ     ??HalKeyPoll_4
    406                   //will create the shiftevent(exit the shift hal_key_mode)
    407                  { 
    408                    //keys &= ~HAL_KEY_PWR;
    409                    hal_key_mode = 0x00;
   \   00009C   E4           CLR     A
   \   00009D   F0           MOVX    @DPTR,A
    410                    (pHalKeyProcessFunction) (keysbounce, HAL_KEY_STATE_SHIFTBOUNCE);
   \   00009E                ; Setup parameters for indirect call
   \   00009E   7A02         MOV     R2,#0x2
   \   0000A0   8002         SJMP    ??HalKeyPoll_5
    411                  }
    412                  else
    413                  {
    414                    (pHalKeyProcessFunction) (keysbounce, HAL_KEY_STATE_NORMAL);
   \                     ??HalKeyPoll_4:
   \   0000A2                ; Setup parameters for indirect call
   \   0000A2   7A00         MOV     R2,#0x0
   \                     ??HalKeyPoll_5:
   \   0000A4   EE           MOV     A,R6
   \   0000A5   F9           MOV     R1,A
   \   0000A6   90....       MOV     DPTR,#pHalKeyProcessFunction + 1
   \   0000A9   E0           MOVX    A,@DPTR
   \   0000AA   F583         MOV     DPH,A
   \   0000AC   8882         MOV     DPL,R0
   \   0000AE   12....       LCALL   ?CALL_IND
    415                  }
    416                }
    417              }
    418              
    419            }
    420            else
    421            {
    422              ; /* Key interrupt handled here */
    423            }
    424            
    425            // the maxium gap between the depressed
    426            if(key_depressed_gap >= MAX_DOUBLE_HIT_GAP)
   \                     ??HalKeyPoll_0:
   \   0000B1   90....       MOV     DPTR,#key_depressed_gap
   \   0000B4   E0           MOVX    A,@DPTR
   \   0000B5   C3           CLR     C
   \   0000B6   9408         SUBB    A,#0x8
   \   0000B8   4017         JC      ??HalKeyPoll_6
    427            {
    428             // exit the double_hit mode only when the double_hit
    429            // change from TRUE to FALSE
    430              if(double_hit) 
   \   0000BA   90....       MOV     DPTR,#double_hit
   \   0000BD   E0           MOVX    A,@DPTR
   \   0000BE   6006         JZ      ??HalKeyPoll_7
    431              {
    432                hal_key_mode = 0x03;  
   \   0000C0   90....       MOV     DPTR,#hal_key_mode
   \   0000C3   7403         MOV     A,#0x3
   \   0000C5   F0           MOVX    @DPTR,A
    433              }
    434              key_depressed_gap = MAX_DOUBLE_HIT_GAP - 1;
   \                     ??HalKeyPoll_7:
   \   0000C6   90....       MOV     DPTR,#key_depressed_gap
   \   0000C9   7407         MOV     A,#0x7
   \   0000CB   F0           MOVX    @DPTR,A
    435              double_hit = FALSE;//the gap is the maxium value,can never be double hit
   \   0000CC   90....       MOV     DPTR,#double_hit
   \   0000CF   E4           CLR     A
   \   0000D0   F0           MOVX    @DPTR,A
    436            }
    437            
    438            if(keysbounce)// clear the gap between the key depressed ,recount the gap
   \                     ??HalKeyPoll_6:
   \   0000D1   EE           MOV     A,R6
   \   0000D2   6005         JZ      ??HalKeyPoll_8
    439            {
    440               key_depressed_gap = 0; 
   \   0000D4   90....       MOV     DPTR,#key_depressed_gap
   \   0000D7   E4           CLR     A
   \   0000D8   F0           MOVX    @DPTR,A
    441            }
    442            key_depressed_gap++;//  the (double_hit_gap * 100) ms  between the keys
   \                     ??HalKeyPoll_8:
   \   0000D9   90....       MOV     DPTR,#key_depressed_gap
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   04           INC     A
   \   0000DE   F0           MOVX    @DPTR,A
    443            // depressed
    444          }
   \   0000DF   7F01         MOV     R7,#0x1
   \   0000E1   02....       LJMP    ?BANKED_LEAVE_XDATA
    445          
    446          /**************************************************************************************************
    447           * @fn      HalKeyEnterSleep
    448           *
    449           * @brief  - Get called to enter sleep hal_key_mode
    450           *
    451           * @param
    452           *
    453           * @return
    454           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    455          void HalKeyEnterSleep ( void )
   \                     HalKeyEnterSleep:
    456          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    457            ;
    458          }
   \   000000   02....       LJMP    ?BRET
    459          
    460          /**************************************************************************************************
    461           * @fn      HalKeyExitSleep
    462           *
    463           * @brief   - Get called when sleep is over
    464           *
    465           * @param
    466           *
    467           * @return  - return saved keys
    468           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    469          uint8 HalKeyExitSleep ( void )
   \                     HalKeyExitSleep:
    470          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    471            return ( HalKeyRead () );
   \   000004                ; Setup parameters for call to function HalKeyRead
   \   000004   12....       LCALL   ??HalKeyRead?relay
   \   000007   02....       LJMP    ?Subroutine0 & 0xFFFF
    472          }

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyBounce?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyBounce

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyPoll?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyPoll

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyEnterSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyEnterSleep

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyExitSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyExitSleep
    473          
    474          #else
    475          
    476          void HalKeyInit(void){}
    477          void HalKeyConfig(bool interruptEnable, halKeyCBack_t cback){}
    478          uint8 HalKeyRead(void){ return 0;}
    479          void HalKeyPoll(void){}
    480          
    481          #endif /* HAL_KEY */
    482          
    483          
    484          
    485          
    486          
    487          /**************************************************************************************************
    488          **************************************************************************************************/
    489          
    490          
    491          

   Maximum stack usage in bytes:

     Function               ISTACK PSTACK XSTACK
     --------               ------ ------ ------
     HalKeyBounce               3      0      9
     HalKeyConfig               0      0      9
       -> osal_stop_timerEx     0      0     18
       -> osal_set_event        0      0     18
     HalKeyEnterSleep           0      0      0
     HalKeyExitSleep            2      0      0
       -> HalKeyRead            4      0      0
     HalKeyInit                 2      0      0
     HalKeyPoll                 0      0      9
       -> HalKeyRead            0      0     18
       -> HalKeyBounce          0      0     18
     HalKeyRead                 0      0      9


   Segment part sizes:

     Function/Label           Bytes
     --------------           -----
     _A_P0                       1
     P0INP                       1
     P0IEN                       1
     _A_IEN1                     1
     P0SEL                       1
     P2INP                       1
     P0DIR                       1
     pHalKeyProcessFunction      2
     HalKeyConfigured            1
     Hal_KeyIntEnable            1
     double_hit_count            1
     double_hit                  1
     key_depressed_gap           1
     halKeySavedKeystate         1
     halKeySavedKeybounce        1
     keystate                    1
     hal_key_mode                1
     HalKeyInit                 36
     ?Subroutine0                7
     HalKeyConfig               68
     HalKeyRead                 42
     HalKeyBounce              112
     HalKeyPoll                228
     HalKeyEnterSleep            3
     HalKeyExitSleep            10
     ??HalKeyInit?relay          6
     ??HalKeyConfig?relay        6
     ??HalKeyRead?relay          6
     ??HalKeyBounce?relay        6
     ??HalKeyPoll?relay          6
     ??HalKeyEnterSleep?relay    6
     ??HalKeyExitSleep?relay     6

 
 506 bytes in segment BANKED_CODE
  42 bytes in segment BANK_RELAYS
   7 bytes in segment SFR_AN
  11 bytes in segment XDATA_Z
 
 548 bytes of CODE  memory
   0 bytes of DATA  memory (+ 7 bytes shared)
  11 bytes of XDATA memory

Errors: none
Warnings: none
