###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.10194/W32 for 8051         21/Apr/2015  16:52:43 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Components\hal\target\CC2530EB\h #
#                          al_adc.c                                           #
#    Command line       =  -f C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice #
#                          -Project-for-editing\Projects\zstack\MyEnddevice\E #
#                          ndDevice\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev #
#                          .cfg (-DCPU32MHZ -DROOT=__near_func                #
#                          -DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6         #
#                          -DMAC_CFG_RX_MAX=3) -f C:\Users\William\Desktop\±œ #
#                          “µ…Ëº∆\SRC\EndDevice-Project-for-editing\Projects\ #
#                          zstack\MyEnddevice\EndDevice\CC2530DB\..\..\..\Too #
#                          ls\CC2530DB\f8wConfig.cfg (-DZIGBEEPRO -DSECURE=0  #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x02000000                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 C:\Users\William\Desktop\±œ #
#                          “µ…Ëº∆\SRC\EndDevice-Project-for-editing\Component #
#                          s\hal\target\CC2530EB\hal_adc.c -D NWK_AUTO_POLL   #
#                          -D NV_RESTORE=1 -D xZTOOL_P1 -D xMT_TASK -D        #
#                          xMT_SYS_FUNC -D xMT_ZDO_FUNC -D                    #
#                          xLCD_SUPPORTED=DEBUG -lC                           #
#                          C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\EndDeviceEB\List\ -lA               #
#                          C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\EndDeviceEB\List\ --diag_suppress   #
#                          Pe001,Pa010 -o C:\Users\William\Desktop\±œ“µ…Ëº∆\S #
#                          RC\EndDevice-Project-for-editing\Projects\zstack\M #
#                          yEnddevice\EndDevice\CC2530DB\EndDeviceEB\Obj\ -e  #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice #
#                          -Project-for-editing\Projects\zstack\MyEnddevice\E #
#                          ndDevice\CC2530DB\ -I C:\Users\William\Desktop\±œ“ #
#                          µ…Ëº∆\SRC\EndDevice-Project-for-editing\Projects\z #
#                          stack\MyEnddevice\EndDevice\CC2530DB\..\Source\    #
#                          -I C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice #
#                          -Project-for-editing\Projects\zstack\MyEnddevice\E #
#                          ndDevice\CC2530DB\..\..\..\ZMain\TI2530DB\ -I      #
#                          C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\..\..\..\..\..\Components\hal\inclu #
#                          de\ -I C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDe #
#                          vice-Project-for-editing\Projects\zstack\MyEnddevi #
#                          ce\EndDevice\CC2530DB\..\..\..\..\..\Components\ha #
#                          l\target\CC2530EB\ -I C:\Users\William\Desktop\±œ“ #
#                          µ…Ëº∆\SRC\EndDevice-Project-for-editing\Projects\z #
#                          stack\MyEnddevice\EndDevice\CC2530DB\..\..\..\..\. #
#                          .\Components\mac\include\ -I                       #
#                          C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\..\..\..\..\..\Components\mac\high_ #
#                          level\ -I C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\En #
#                          dDevice-Project-for-editing\Projects\zstack\MyEndd #
#                          evice\EndDevice\CC2530DB\..\..\..\..\..\Components #
#                          \mac\low_level\srf04\ -I                           #
#                          C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\..\..\..\..\..\Components\mac\low_l #
#                          evel\srf04\single_chip\ -I                         #
#                          C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\..\..\..\..\..\Components\mt\ -I    #
#                          C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\..\..\..\..\..\Components\osal\incl #
#                          ude\ -I C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndD #
#                          evice-Project-for-editing\Projects\zstack\MyEnddev #
#                          ice\EndDevice\CC2530DB\..\..\..\..\..\Components\s #
#                          ervices\saddr\ -I C:\Users\William\Desktop\±œ“µ…Ëº #
#                          ∆\SRC\EndDevice-Project-for-editing\Projects\zstac #
#                          k\MyEnddevice\EndDevice\CC2530DB\..\..\..\..\..\Co #
#                          mponents\services\sdata\ -I                        #
#                          C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\..\..\..\..\..\Components\stack\af\ #
#                           -I C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevic #
#                          e-Project-for-editing\Projects\zstack\MyEnddevice\ #
#                          EndDevice\CC2530DB\..\..\..\..\..\Components\stack #
#                          \nwk\ -I C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\End #
#                          Device-Project-for-editing\Projects\zstack\MyEndde #
#                          vice\EndDevice\CC2530DB\..\..\..\..\..\Components\ #
#                          stack\sapi\ -I C:\Users\William\Desktop\±œ“µ…Ëº∆\S #
#                          RC\EndDevice-Project-for-editing\Projects\zstack\M #
#                          yEnddevice\EndDevice\CC2530DB\..\..\..\..\..\Compo #
#                          nents\stack\sec\ -I C:\Users\William\Desktop\±œ“µ… #
#                          Ëº∆\SRC\EndDevice-Project-for-editing\Projects\zst #
#                          ack\MyEnddevice\EndDevice\CC2530DB\..\..\..\..\..\ #
#                          Components\stack\sys\ -I                           #
#                          C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\..\..\..\..\..\Components\stack\zdo #
#                          \ -I C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevi #
#                          ce-Project-for-editing\Projects\zstack\MyEnddevice #
#                          \EndDevice\CC2530DB\..\..\..\..\..\Components\zmac #
#                          \ -I C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevi #
#                          ce-Project-for-editing\Projects\zstack\MyEnddevice #
#                          \EndDevice\CC2530DB\..\..\..\..\..\Components\zmac #
#                          \f8w\ -Ohz                                         #
#    List file          =  C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\EndDeviceEB\List\hal_adc.lst        #
#    Object file        =  C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Pr #
#                          oject-for-editing\Projects\zstack\MyEnddevice\EndD #
#                          evice\CC2530DB\EndDeviceEB\Obj\hal_adc.r51         #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\William\Desktop\±œ“µ…Ëº∆\SRC\EndDevice-Project-for-editing\Components\hal\target\CC2530EB\hal_adc.c
      1          /**************************************************************************************************
      2            Filename:       hal_adc.c
      3            Revised:        $Date: 2010-03-12 16:10:36 -0800 (Fri, 12 Mar 2010) $
      4            Revision:       $Revision: 21910 $
      5          
      6            Description:    This file contains the interface to the HAL ADC.
      7          
      8          
      9            Copyright 2006-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED ìAS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /**************************************************************************************************
     41           *                                           INCLUDES
     42           **************************************************************************************************/
     43          
     44          #include  "hal_adc.h"

   \                                 In  segment SFR_AN, at 0xb4
   \   unsigned char volatile __sfr ADCCON1
   \                     ADCCON1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb6
   \   unsigned char volatile __sfr ADCCON3
   \                     ADCCON3:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xba
   \   unsigned char volatile __sfr ADCL
   \                     ADCL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbb
   \   unsigned char volatile __sfr ADCH
   \                     ADCH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf2
   \   unsigned char volatile __sfr ADCCFG
   \                     ADCCFG:
   \   000000                DS 1
     45          #include  "hal_defs.h"
     46          #include  "hal_mcu.h"
     47          #include  "hal_types.h"
     48          
     49          /**************************************************************************************************
     50           *                                            CONSTANTS
     51           **************************************************************************************************/
     52          #define HAL_ADC_EOC         0x80    /* End of Conversion bit */
     53          #define HAL_ADC_START       0x40    /* Starts Conversion */
     54          
     55          #define HAL_ADC_STSEL_EXT   0x00    /* External Trigger */
     56          #define HAL_ADC_STSEL_FULL  0x10    /* Full Speed, No Trigger */
     57          #define HAL_ADC_STSEL_T1C0  0x20    /* Timer1, Channel 0 Compare Event Trigger */
     58          #define HAL_ADC_STSEL_ST    0x30    /* ADCCON1.ST =1 Trigger */
     59          
     60          #define HAL_ADC_RAND_NORM   0x00    /* Normal Operation */
     61          #define HAL_ADC_RAND_LFSR   0x04    /* Clock LFSR */
     62          #define HAL_ADC_RAND_SEED   0x08    /* Seed Modulator */
     63          #define HAL_ADC_RAND_STOP   0x0c    /* Stop Random Generator */
     64          #define HAL_ADC_RAND_BITS   0x0c    /* Bits [3:2] */
     65          
     66          #define HAL_ADC_DEC_064     0x00    /* Decimate by 64 : 8-bit resolution */
     67          #define HAL_ADC_DEC_128     0x10    /* Decimate by 128 : 10-bit resolution */
     68          #define HAL_ADC_DEC_256     0x20    /* Decimate by 256 : 12-bit resolution */
     69          #define HAL_ADC_DEC_512     0x30    /* Decimate by 512 : 14-bit resolution */
     70          #define HAL_ADC_DEC_BITS    0x30    /* Bits [5:4] */
     71          
     72          #define HAL_ADC_STSEL       HAL_ADC_STSEL_ST
     73          #define HAL_ADC_RAND_GEN    HAL_ADC_RAND_STOP
     74          #define HAL_ADC_REF_VOLT    HAL_ADC_REF_AVDD
     75          #define HAL_ADC_DEC_RATE    HAL_ADC_DEC_064
     76          #define HAL_ADC_SCHN        HAL_ADC_CHN_VDD3
     77          #define HAL_ADC_ECHN        HAL_ADC_CHN_GND
     78          
     79          /* ------------------------------------------------------------------------------------------------
     80           *                                       Local Variables
     81           * ------------------------------------------------------------------------------------------------
     82           */
     83          uint16 HalReadRoomTemperature();
     84          
     85          uint16 HalReadFloorTemperature();
     86          
     87          
     88          
     89          
     90          #if (HAL_ADC == TRUE)

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     91          static uint8 adcRef;
   \                     adcRef:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     92          #endif
     93          
     94          /**************************************************************************************************
     95           * @fn      HalAdcInit
     96           *
     97           * @brief   Initialize ADC Service
     98           *
     99           * @param   None
    100           *
    101           * @return  None
    102           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    103          void HalAdcInit (void)
   \                     HalAdcInit:
    104          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    105          #if (HAL_ADC == TRUE)
    106            adcRef = HAL_ADC_REF_VOLT; // use the vdd for reference
   \   000004   90....       MOV     DPTR,#adcRef
   \   000007   7480         MOV     A,#-0x80
   \   000009   F0           MOVX    @DPTR,A
    107            ADCCFG |= (BV(6) + BV(5)); // for the  room temperature and the floor temperature use
   \   00000A   43F260       ORL     0xf2,#0x60
    108          #endif
    109          }
   \   00000D                REQUIRE ?Subroutine0
   \   00000D                REQUIRE ADCCFG
   \   00000D                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    110          
    111          /**************************************************************************************************
    112           * @fn      HalAdcRead
    113           *
    114           * @brief   Read the ADC based on given channel and resolution
    115           *
    116           * @param   channel - channel where ADC will be read
    117           * @param   resolution - the resolution of the value
    118           *
    119           * @return  16 bit value of the ADC in offset binary format.
    120           *
    121           *          Note that the ADC is "bipolar", which means the GND (0V) level is mid-scale.
    122           *          Note2: This function assumes that ADCCON3 contains the voltage reference.
    123           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    124          uint16 HalAdcRead (uint8 channel, uint8 resolution)
   \                     HalAdcRead:
    125          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FC           MOV     R4,A
   \   000007   EA           MOV     A,R2
   \   000008   FD           MOV     R5,A
    126            int16  reading = 0;
    127          
    128          #if (HAL_ADC == TRUE)
    129            uint8   i, resbits;
    130            uint8  adcChannel = 1;
   \   000009   7901         MOV     R1,#0x1
    131          
    132            /*
    133             * If Analog input channel is AIN0..AIN7, make sure corresponing P0 I/O pin is enabled.  The code
    134             * does NOT disable the pin at the end of this function.  I think it is better to leave the pin
    135             * enabled because the results will be more accurate.  Because of the inherent capacitance on the
    136             * pin, it takes time for the voltage on the pin to charge up to its steady-state level.  If
    137             * HalAdcRead() has to turn on the pin for every conversion, the results may show a lower voltage
    138             * than actuality because the pin did not have time to fully charge.
    139             */
    140            if (channel < 8)
   \   00000B   EC           MOV     A,R4
   \   00000C   C3           CLR     C
   \   00000D   9408         SUBB    A,#0x8
   \   00000F   500E         JNC     ??HalAdcRead_0
    141            {
    142              for (i=0; i < channel; i++)
   \   000011   7800         MOV     R0,#0x0
   \   000013   8005         SJMP    ??HalAdcRead_1
    143              {
    144                adcChannel <<= 1;
   \                     ??HalAdcRead_2:
   \   000015   E9           MOV     A,R1
   \   000016   C3           CLR     C
   \   000017   33           RLC     A
   \   000018   F9           MOV     R1,A
    145              }
   \   000019   08           INC     R0
   \                     ??HalAdcRead_1:
   \   00001A   E8           MOV     A,R0
   \   00001B   C3           CLR     C
   \   00001C   9C           SUBB    A,R4
   \   00001D   40F6         JC      ??HalAdcRead_2
    146            }
    147          
    148            /* Enable channel */
    149            ADCCFG |= adcChannel;
   \                     ??HalAdcRead_0:
   \   00001F   E9           MOV     A,R1
   \   000020   42F2         ORL     0xf2,A
    150          
    151            /* Convert resolution to decimation rate */
    152            switch (resolution)
   \   000022   ED           MOV     A,R5
   \   000023   6008         JZ      ??HalAdcRead_3
   \   000025   14           DEC     A
   \   000026   6009         JZ      ??HalAdcRead_4
   \   000028   14           DEC     A
   \   000029   600A         JZ      ??HalAdcRead_5
   \   00002B   800C         SJMP    ??HalAdcRead_6
    153            {
    154              case HAL_ADC_RESOLUTION_7:
    155                resbits = HAL_ADC_DEC_064;
   \                     ??HalAdcRead_3:
   \   00002D   7800         MOV     R0,#0x0
    156                break;
   \   00002F   800A         SJMP    ??HalAdcRead_7
    157              case HAL_ADC_RESOLUTION_9:
    158                resbits = HAL_ADC_DEC_128;
   \                     ??HalAdcRead_4:
   \   000031   7810         MOV     R0,#0x10
    159                break;
   \   000033   8006         SJMP    ??HalAdcRead_7
    160              case HAL_ADC_RESOLUTION_10:
    161                resbits = HAL_ADC_DEC_256;
   \                     ??HalAdcRead_5:
   \   000035   7820         MOV     R0,#0x20
    162                break;
   \   000037   8002         SJMP    ??HalAdcRead_7
    163              case HAL_ADC_RESOLUTION_12:
    164              default:
    165                resbits = HAL_ADC_DEC_512;
   \                     ??HalAdcRead_6:
   \   000039   7830         MOV     R0,#0x30
    166                break;
    167            }
    168          
    169            /* writing to this register starts the extra conversion */
    170            ADCCON3 = channel | resbits | adcRef;
   \                     ??HalAdcRead_7:
   \   00003B   90....       MOV     DPTR,#adcRef
   \   00003E   EC           MOV     A,R4
   \   00003F   48           ORL     A,R0
   \   000040   F8           MOV     R0,A
   \   000041   E0           MOVX    A,@DPTR
   \   000042   48           ORL     A,R0
   \   000043   F5B6         MOV     0xb6,A
    171          
    172            /* Wait for the conversion to be done */
    173            while (!(ADCCON1 & HAL_ADC_EOC));
   \                     ??HalAdcRead_8:
   \   000045   E5B4         MOV     A,0xb4
   \   000047   A2E7         MOV     C,0xE0 /* A   */.7
   \   000049   50FA         JNC     ??HalAdcRead_8
    174          
    175            /* Disable channel after done conversion */
    176            ADCCFG &= (adcChannel ^ 0xFF);
   \   00004B   74FF         MOV     A,#-0x1
   \   00004D   69           XRL     A,R1
   \   00004E   52F2         ANL     0xf2,A
    177          
    178            /* Read the result */
    179            reading = (int16) (ADCL);
   \   000050   E5BA         MOV     A,0xba
   \   000052   F5..         MOV     ?V0 + 0,A
    180            reading |= (int16) (ADCH << 8);
   \   000054   E5BB         MOV     A,0xbb
   \   000056   AA..         MOV     R2,?V0 + 0
   \   000058   FB           MOV     R3,A
    181          
    182            /* Treat small negative as 0 */
    183            if (reading < 0)
   \   000059   C3           CLR     C
   \   00005A   9400         SUBB    A,#0x0
   \   00005C   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00005E   65D0         XRL     A,PSW
   \   000060   33           RLC     A
   \   000061   5004         JNC     ??HalAdcRead_9
    184              reading = 0;
   \   000063   7A00         MOV     R2,#0x0
   \   000065   7B00         MOV     R3,#0x0
    185          
    186            switch (resolution)
   \                     ??HalAdcRead_9:
   \   000067   ED           MOV     A,R5
   \   000068   6008         JZ      ??HalAdcRead_10
   \   00006A   14           DEC     A
   \   00006B   600D         JZ      ??HalAdcRead_11
   \   00006D   14           DEC     A
   \   00006E   6012         JZ      ??HalAdcRead_12
   \   000070   8018         SJMP    ??HalAdcRead_13
    187            {
    188              case HAL_ADC_RESOLUTION_7:
    189                reading >>= 8;
   \                     ??HalAdcRead_10:
   \   000072   8A..         MOV     ?V0 + 0,R2
   \   000074   8B..         MOV     ?V0 + 1,R3
   \   000076   7408         MOV     A,#0x8
   \   000078   8016         SJMP    ??HalAdcRead_14
    190                break;
    191              case HAL_ADC_RESOLUTION_9:
    192                reading >>= 6;
   \                     ??HalAdcRead_11:
   \   00007A   8A..         MOV     ?V0 + 0,R2
   \   00007C   8B..         MOV     ?V0 + 1,R3
   \   00007E   7406         MOV     A,#0x6
   \   000080   800E         SJMP    ??HalAdcRead_14
    193                break;
    194              case HAL_ADC_RESOLUTION_10:
    195                reading >>= 4;
   \                     ??HalAdcRead_12:
   \   000082   8A..         MOV     ?V0 + 0,R2
   \   000084   8B..         MOV     ?V0 + 1,R3
   \   000086   7404         MOV     A,#0x4
   \   000088   8006         SJMP    ??HalAdcRead_14
    196                break;
    197              case HAL_ADC_RESOLUTION_12:
    198              default:
    199                reading >>= 2;
   \                     ??HalAdcRead_13:
   \   00008A   8A..         MOV     ?V0 + 0,R2
   \   00008C   8B..         MOV     ?V0 + 1,R3
   \   00008E   7402         MOV     A,#0x2
   \                     ??HalAdcRead_14:
   \   000090   78..         MOV     R0,#?V0 + 0
   \   000092   12....       LCALL   ?SS_SHR
    200              break;
    201            }
   \   000095   80..         SJMP    ??Subroutine2_0
   \   000097                REQUIRE ADCCFG
   \   000097                REQUIRE ADCCON3
   \   000097                REQUIRE ADCCON1
   \   000097                REQUIRE ADCL
   \   000097                REQUIRE ADCH
    202          #else
    203            // unused arguments
    204            (void) channel;
    205            (void) resolution;
    206          #endif
    207          
    208            return ((uint16)reading);
    209          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine2_0:
   \   000000   AA..         MOV     R2,?V0 + 0
   \   000002   AB..         MOV     R3,?V0 + 1
   \   000004   7F02         MOV     R7,#0x2
   \   000006   02....       LJMP    ?BANKED_LEAVE_XDATA
    210          
    211          /**************************************************************************************************
    212           * @fn      HalAdcSetReference
    213           *
    214           * @brief   Sets the reference voltage for the ADC and initializes the service
    215           *
    216           * @param   reference - the reference voltage to be used by the ADC
    217           *
    218           * @return  none
    219           *
    220           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    221          void HalAdcSetReference ( uint8 reference )
   \                     HalAdcSetReference:
    222          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    223          #if (HAL_ADC == TRUE)
    224            adcRef = reference;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#adcRef
   \   000008   F0           MOVX    @DPTR,A
    225          #endif
    226          }
   \   000009   02....       LJMP    ?Subroutine0 & 0xFFFF
    227          
    228          /*********************************************************************
    229           * @fn      HalAdcCheckVdd
    230           *
    231           * @brief   Check for minimum Vdd specified.
    232           *
    233           * @param   vdd - The board-specific Vdd reading to check for.
    234           *
    235           * @return  TRUE if the Vdd measured is greater than the 'vdd' minimum parameter;
    236           *          FALSE if not.
    237           *
    238           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    239          bool HalAdcCheckVdd(uint8 vdd)
   \                     HalAdcCheckVdd:
    240          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV     A,R1
   \   000001   F8           MOV     R0,A
    241            ADCCON3 = 0x0F;
   \   000002   75B60F       MOV     0xb6,#0xf
    242            while (!(ADCCON1 & 0x80));
   \                     ??HalAdcCheckVdd_0:
   \   000005   E5B4         MOV     A,0xb4
   \   000007   A2E7         MOV     C,0xE0 /* A   */.7
   \   000009   50FA         JNC     ??HalAdcCheckVdd_0
    243            return (ADCH > vdd);
   \   00000B   E8           MOV     A,R0
   \   00000C   C3           CLR     C
   \   00000D   95BB         SUBB    A,0xbb
   \   00000F   5004         JNC     ??HalAdcCheckVdd_1
   \   000011   7901         MOV     R1,#0x1
   \   000013   8002         SJMP    ??HalAdcCheckVdd_2
   \                     ??HalAdcCheckVdd_1:
   \   000015   7900         MOV     R1,#0x0
   \                     ??HalAdcCheckVdd_2:
   \   000017   02....       LJMP    ?BRET
   \   00001A                REQUIRE ADCCON3
   \   00001A                REQUIRE ADCCON1
   \   00001A                REQUIRE ADCH
    244          }
    245          
    246          
    247          /*********************************************************************
    248           * @fn      HalSampleRoomTemperatureADC
    249           *
    250           * @brief   read the room temperature ADC result
    251           *
    252           * @param  none
    253           *
    254           * @return  the ADC result
    255           *          
    256           *
    257           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    258          uint16 HalSampleRoomTemperatureADC(void)
   \                     HalSampleRoomTemperatureADC:
    259          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    260            uint16 results = 0;
    261            ADCCON3 = ROOM_TEMPERATURE_CHN | HAL_ADC_DEC_512 | adcRef;
   \   000005   90....       MOV     DPTR,#adcRef
   \   000008   E0           MOVX    A,@DPTR
   \   000009   4435         ORL     A,#0x35
   \   00000B   F5B6         MOV     0xb6,A
    262            
    263            while (!(ADCCON1 & HAL_ADC_EOC));
   \                     ??HalSampleRoomTemperatureADC_0:
   \   00000D   E5B4         MOV     A,0xb4
   \   00000F   A2E7         MOV     C,0xE0 /* A   */.7
   \   000011   50FA         JNC     ??HalSampleRoomTemperatureADC_0
    264            
    265            results = (uint16)(ADCH);
   \   000013                REQUIRE ?Subroutine1
   \   000013                REQUIRE ADCCON3
   \   000013                REQUIRE ADCCON1
   \   000013                REQUIRE ADCH
   \   000013                REQUIRE ADCL
   \   000013                ; // Fall through to label ?Subroutine1
    266            results <<= 8;
    267            results += (uint16)(ADCL);
    268            results >>=  4;
    269            
    270            return results;
    271          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   E5BB         MOV     A,0xbb
   \   000002   85BA..       MOV     ?V0 + 0,0xba
   \   000005   F5..         MOV     ?V0 + 1,A
   \   000007   7404         MOV     A,#0x4
   \   000009   78..         MOV     R0,#?V0 + 0
   \   00000B   12....       LCALL   ?US_SHR
   \   00000E                REQUIRE ??Subroutine2_0
   \   00000E                ; // Fall through to label ??Subroutine2_0
    272          
    273          
    274          /*********************************************************************
    275           * @fn      HalSampleFloorTemperatureADC
    276           *
    277           * @brief   read the floor temperature ADC result
    278           *
    279           * @param  none
    280           *
    281           * @return  the ADC result
    282           *          
    283           *
    284           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    285          uint16 HalSampleFloorTemperatureADC(void)
   \                     HalSampleFloorTemperatureADC:
    286          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    287            uint16 results = 0;
    288            ADCCON3 = FLOOR_TEMPERATURE_CHN | HAL_ADC_DEC_512 | adcRef;
   \   000005   90....       MOV     DPTR,#adcRef
   \   000008   E0           MOVX    A,@DPTR
   \   000009   4436         ORL     A,#0x36
   \   00000B   F5B6         MOV     0xb6,A
    289            
    290            while (!(ADCCON1 & HAL_ADC_EOC));
   \                     ??HalSampleFloorTemperatureADC_0:
   \   00000D   E5B4         MOV     A,0xb4
   \   00000F   A2E7         MOV     C,0xE0 /* A   */.7
   \   000011   50FA         JNC     ??HalSampleFloorTemperatureADC_0
    291            
    292            results = (uint16)(ADCH);
   \   000013   80..         SJMP    ?Subroutine1
   \   000015                REQUIRE ADCCON3
   \   000015                REQUIRE ADCCON1
   \   000015                REQUIRE ADCH
   \   000015                REQUIRE ADCL
    293            results <<= 8;
    294            results += (uint16)(ADCL);
    295            results >>=  4;
    296            
    297            return results;
    298            
    299          }

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcSetReference?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcSetReference

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcCheckVdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcCheckVdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalSampleRoomTemperatureADC?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalSampleRoomTemperatureADC

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalSampleFloorTemperatureADC?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalSampleFloorTemperatureADC
    300          
    301          
    302          /**************************************************************************************************
    303          **************************************************************************************************/

   Maximum stack usage in bytes:

     Function                     ISTACK PSTACK XSTACK
     --------                     ------ ------ ------
     HalAdcCheckVdd                   0      0      0
     HalAdcInit                       2      0      0
     HalAdcRead                       0      0     10
     HalAdcSetReference               2      0      0
     HalSampleFloorTemperatureADC     0      0     10
     HalSampleRoomTemperatureADC      0      0     10


   Segment part sizes:

     Function/Label                       Bytes
     --------------                       -----
     ADCCON1                                 1
     ADCCON3                                 1
     ADCL                                    1
     ADCH                                    1
     ADCCFG                                  1
     adcRef                                  1
     HalAdcInit                             13
     ?Subroutine0                            7
     HalAdcRead                            151
     ??Subroutine2_0                         9
     HalAdcSetReference                     12
     HalAdcCheckVdd                         26
     HalSampleRoomTemperatureADC            19
     ?Subroutine1                           14
     HalSampleFloorTemperatureADC           21
     ??HalAdcInit?relay                      6
     ??HalAdcRead?relay                      6
     ??HalAdcSetReference?relay              6
     ??HalAdcCheckVdd?relay                  6
     ??HalSampleRoomTemperatureADC?relay     6
     ??HalSampleFloorTemperatureADC?relay    6

 
 272 bytes in segment BANKED_CODE
  36 bytes in segment BANK_RELAYS
   5 bytes in segment SFR_AN
   1 byte  in segment XDATA_Z
 
 308 bytes of CODE  memory
   0 bytes of DATA  memory (+ 5 bytes shared)
   1 byte  of XDATA memory

Errors: none
Warnings: none
